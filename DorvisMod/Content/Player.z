class Player : ScriptComponent
{
    [Property]
    var Speed : Real = 10.0;
    
    [Property]
    var LookSpeed : Real = 0.01;
    
    [Property]
    var JumpVelocity : Real = 6.0;
    
    [Property]
    var InteractDistance : Real = 6.0;
    
    [Property]
    var Active : Boolean = true;
    
    [Property]
    var InteractSound : SoundCue = SoundCue.Find("Interact");
    [Property]
    var ChangeToolSound : SoundCue = SoundCue.Find("ChangeTool");
    
    [Property]
    var FovToSpeed : Real = 3.0;
    [Property]
    var MaxFovChange : Real = 5.0;
    [Property]
    var FovSmoothing : Real = 0.3;
    
    [Property]
    var MinSpeedForFovChange : Real = 20.0;
    
    
    var Peer : LockStepPeer = null;
    var CameraCog : Cog = null;
    
    var RotationAngles : Real2 = local Real2(0.0, 0.0);
    var ToolContainer : Cog = null;
    var Id : Integer = 0;
    var UndoCounter : Integer = 0;
    
    var Movement : Real3 = local Real3();
    
    var Hud : Space = null;
    var HudContextText : ShadowText = null;
    var HudToolText : ShadowText = null;
    var HudToolSubText : ShadowText = null;
    var HudUndoText : ShadowText = null;
    var HudNotifications : Notifications = null;
    
    var InteractMessage : String = null;
    var InteractCog : Cog = null;
    
    var Tools : Array[Cog] = new Array[Cog]();
    var ActiveTool : Cog = null;
    
    var FreezeKeyboardInput : Boolean = false;
    var FreezeMouseInput : Boolean = false;
    
    // Only used for client side effects that have absolutely no baring on gameplay
    var UnsafeIsLocal : Boolean = false;
    
    var InitialFieldOfView : Real = 80.0;
    var FovTarget : Real = 80.0;
    
    [Property]
    var HudToCreate : Level = Level.Find("Hud");
    
    
    // For some reason this results in a type not found error
    //var UndoStack : Array[delegate()] = new Array[delegate()]();
    var UndoStack : Array[Undo] = new Array[Undo]();
    
    var WorldLookForward : Real3
    {
        get { return this.CameraCog.Orientation.WorldForward; }
    }
    var WorldLookUp : Real3
    {
        get { return this.CameraCog.Orientation.WorldUp; }
    }
    var WorldLookRight : Real3
    {
        get { return this.CameraCog.Orientation.WorldRight; }
    }
    
    var WorldLookPosition : Real3
    {
        get { return this.CameraCog.Transform.WorldTranslation; }
    }
    
    constructor() : base()
    {
    }

    function Initialize(init : CogInitializer)
    {
    }
    
    function LockStepInitialize(peer : LockStepPeer, id : Integer, unsafeIsLocal : Boolean)
    {
        this.UnsafeIsLocal = unsafeIsLocal;
        this.Id = id;
        this.Peer = peer;
        this.CameraCog = this.Owner.FindChildByName("Camera");
        
        this.InitialFieldOfView = this.CameraCog.Camera.FieldOfView;
        this.FovTarget = this.InitialFieldOfView;
        
        Zero.Connect(this.Space, Events.LogicUpdate, this.OnLogicUpdate);
        Zero.Connect(peer, Events.LockStepMouseMove, this.OnLockStepMouseMove);
        Zero.Connect(peer, Events.LockStepMouseDown, this.OnLockStepMouseDown);
        Zero.Connect(peer, Events.LockStepMouseScroll, this.OnLockStepMouseScroll);
        Zero.Connect(peer, Events.LockStepMouseUp, this.OnLockStepMouseUp);
        Zero.Connect(peer, Events.LockStepKeyDown, this.OnLockStepKeyDown);
        Zero.Connect(peer, Events.LockStepKeyUp, this.OnLockStepKeyUp);
        
        this.ToolContainer = this.Owner.FindChildByName("ToolContainer");
        
        this.Hud = Zero.Game.CreateSpace("Space");
        
        this.Hud.LoadLevel(this.HudToCreate);
        this.HudContextText = this.Hud.FindObjectByName("ContextText").ShadowText;
        this.HudToolText = this.Hud.FindObjectByName("ToolText").ShadowText;
        this.HudToolSubText = this.Hud.FindObjectByName("ToolSubText").ShadowText;
        this.HudUndoText = this.Hud.FindObjectByName("UndoText").ShadowText;
        this.HudNotifications = this.Hud.FindObjectByName("NotificationManager").Notifications;
        
        // Add all the initial tools
        foreach (var tool in  this.ToolContainer.Hierarchy.Children)
        {
            this.Tools.Add(tool);
        }
        
        // Call this to sign up for most events, as well as setup the first tool
        this.ActiveTool = this.Tools.Get(0);
        this.Activate();
    }
    
    function Destroyed()
    {
        if (this.Hud != null)
        {
            this.Hud.Destroy();
        }
    }
    
    function Activate()
    {
        this.Owner.RigidBody.Static = false;
        this.Owner.Collider.Ghost = false;
        this.Owner.DynamicMotor.Activate();
        this.Active = true;
        this.ActivateTool(this.ActiveTool);
        
        var filter = this.Space.PhysicsSpace.CreateDefaultCastFilter();
        
        for (var i = 0; i < 100; ++i)
        {
            var results = this.Space.PhysicsSpace.CastColliderResults(local Real3(), this.Owner.Collider, filter);
            // Because when activating, we could be inside something, attempt to resolve a portion of the collision
            foreach (var contact in results)
            {
                if (contact.Collider.Ghost)
                {
                    continue;
                }
                
                var hitRoot = contact.ObjectHit.FindRoot();
                
                if (hitRoot == this.Owner.FindRoot())
                {
                    continue;
                }
                
                this.Owner.Transform.WorldTranslation += contact.Normal * local Real3(0.5);
            }
        }
        
        
        //foreach (var contact in this.Owner.Collider.Contacts)
        //{
        //    Console.WriteLine(contact.FirstPoint.WorldNormalTowardsOther);
        //    this.Owner.Transform.WorldTranslation -= contact.FirstPoint.WorldNormalTowardsOther * local Real3(0.75);
        //}
    }
    
    function Deactivate()
    {
        this.Owner.RigidBody.Static = true;
        this.Owner.Collider.Ghost = true;
        this.Owner.DynamicMotor.Deactivate();
        this.Active = false;
        this.DeactivateTool();
        this.HudContextText.Text = "";
    }
    
    function QueueUndo(name : String, action : delegate(undo : Undo) : Boolean) : Undo
    {
        var undo = this.QueueUndo(name);
        undo.Action = action;
        return undo;
    }
    
    function QueueUndo(name : String) : Undo
    {
        var undo = new Undo();
        undo.Name = name;
        ++this.UndoCounter;
        
        var builder = new StringBuilder();
        builder.Write(this.Id);
        builder.Write("_");
        builder.Write(this.UndoCounter);
        
        undo.UniqueName = builder.ToString();
        this.UndoStack.Add(undo);
        
        this.HudUndoText.Text = String.Concatenate("Press [Z] to undo ", name);
        
        return undo;
    }
    
    function AddMovement(e : LockStepKeyEvent, key : Integer, movement : Real3)
    {
        if (e.Key == key)
        {
            this.Movement += movement;
        }
    }
    
    function Notify(message : String)
    {
        this.HudNotifications.Notify(message);
    }
    
    function ResetRotationAngles()
    {
        this.RotationAngles = local Real2();
        this.UpdateRotationAngles();
    }
    
    function UpdateRotationAngles()
    {
        var playerRotation = local Real3(0.0, this.RotationAngles.Y, 0.0);
        var cameraRotation = local Real3(this.RotationAngles.X, Math.Pi, 0.0);
        this.Owner.Transform.EulerAngles = playerRotation;
        this.CameraCog.Transform.EulerAngles  = cameraRotation;
    }
    
    function OnLogicUpdate(e : UpdateEvent)
    {
        if (this.FreezeMouseInput == false)
        {
            this.UpdateRotationAngles();
        }
        if (this.FreezeKeyboardInput == false)
        {
            var movement = this.Owner.Transform.TransformNormal(this.Movement);
            movement.Y = 0.0;
            //this.Owner.DynamicMotor.SetMaxMoveForce(1.0);
            this.Owner.DynamicMotor.MoveInDirection(movement * local Real3(this.Speed), local Real3(0.0, 1.0, 0.0));
        }
        
        this.InteractCog = null;
        this.HudContextText.Text = "";
        
        // Only do interactions if the player is active
        this.InteractMessage = null;
        var result = this.RayCast(this.InteractFilter, this.InteractDistance);
        
        if (result != null)
        {
            this.InteractCog = result.Object;
            this.HudContextText.Text = String.Concatenate("Press [E] to ", this.InteractMessage);
        }
        
        this.FovTarget = this.InitialFieldOfView;
        
        var body = this.Owner.Collider.ActiveBody;
        if (body != null)
        {
            var velocity = body.GetPointVelocity(this.Owner.Transform.WorldTranslation);
            var speed = Math.Length(velocity);
            Console.WriteLine(speed);
            speed -= this.MinSpeedForFovChange;
            
            if (speed > 0.0)
            {
                var fovChange = this.FovToSpeed * speed;
                
                if (fovChange > this.MaxFovChange)
                {
                    fovChange = this.MaxFovChange;
                }
                
                this.FovTarget += fovChange;
            }
        }
        
        var actualFov = this.CameraCog.Camera.FieldOfView;
        var newFov = Math.Lerp(actualFov, this.FovTarget, this.FovSmoothing);
        
        this.CameraCog.Camera.FieldOfView = newFov;
    }
    
    function SendInteractEvent(eventName : String, to : Cog) : InteractEvent
    {
        var toSend = new InteractEvent();
        this.FillPlayerEvent(toSend);
        to.DispatchEvent(eventName, toSend);
        return toSend;
    }
    
    function InteractFilter(hit : Cog) : Boolean
    {
        var e = this.SendInteractEvent("TestInteract", hit);
        this.InteractMessage = e.Message;
        
        // Commenting this in will cause a crash... WHY? (because it's null!)
        //Console.WriteLine(e.Message);
        return e.Message != null;
    }
    
    function RayCast(filter : delegate(hit : Cog) : Boolean) : HitResult
    {
        return this.RayCast(filter, 100000.0);
    }
    
    function RayCast(filter : delegate(hit : Cog) : Boolean, maxDistance : Real) : HitResult
    {
        var ray = local Ray();
        ray.Direction = this.CameraCog.Orientation.WorldForward;
        ray.Start = this.CameraCog.Transform.WorldTranslation;
        
        var foundObject : Cog = null;
        var worldNormal = local Real3();
        var worldPosition = local Real3();
        
        var castResults = this.Space.PhysicsSpace.CastRayResults(ray, 20);
        foreach(var castResult in castResults)
        {
            if (castResult.Distance > maxDistance)
            {
                break;
            }
            
            var hitObject = castResult.ObjectHit;
            
            // Skip ourself
            if (hitObject.FindRoot() == this.Owner)
            {
                continue;
            }
            
            if (filter(hitObject))
            {
                
                foundObject = hitObject;
                worldNormal = castResult.Normal;
                worldPosition = castResult.WorldPosition;
                break;
            }
            
        }
        
        var nullResult : HitResult = null;
        
        if (foundObject == null)
        {
            return nullResult;
        }
        
        var result = new HitResult();
        result.Object = foundObject;
        result.WorldNormal = worldNormal;
        result.WorldPosition = worldPosition;
        
        return result;
    }
    
    function FillPlayerEvent(toSend : PlayerEvent)
    {
        toSend.Player = this;
        toSend.PlayerCog = this.Owner;
    }
    
    function SendMouseEvent(eventName : String, e : LockStepMouseEvent, button : Integer, scroll : Real2)
    {
        var toSend = new PlayerMouseEvent();
        this.FillPlayerEvent(toSend);
        toSend.ScreenDelta = e.ScreenDelta;
        toSend.WorldStart = e.WorldStart;
        toSend.WorldDirection = e.WorldDirection;
        toSend.Button = button;
        toSend.AltPressed = e.AltPressed;
        toSend.ShiftPressed = e.ShiftPressed;
        toSend.CtrlPressed = e.CtrlPressed;
        toSend.ScrollDelta = scroll;
        this.Owner.DispatchEvent(eventName, toSend);
    }
    
    function OnLockStepMouseMove(e : LockStepMouseEvent)
    {
        this.RotationAngles.Y -= e.ScreenDelta.X * this.LookSpeed;
        this.RotationAngles.X -= e.ScreenDelta.Y * this.LookSpeed;
        
        var maxDown = -Math.Pi / 2.0;
        var maxUp = Math.Pi / 2.0;
        
        if (this.RotationAngles.X < maxDown)
        {
            this.RotationAngles.X = maxDown;
        }
        
        if (this.RotationAngles.X > maxUp)
        {
            this.RotationAngles.X = maxUp;
        }
        
        this.SendMouseEvent("PlayerMouseMove", e, -1, local Real2());
    }
    
    function OnLockStepMouseScroll(e : LockStepMouseScrollEvent)
    {
        this.SendMouseEvent("PlayerMouseScroll", e, -1, e.ScrollDelta);
    }
    
    function OnLockStepMouseDown(e : LockStepMouseButtonEvent)
    {
        this.SendMouseEvent("PlayerMouseDown", e, e.Button, local Real2());
    }
    
    function OnLockStepMouseUp(e : LockStepMouseButtonEvent)
    {
        this.SendMouseEvent("PlayerMouseUp", e, e.Button, local Real2());
    }
    
    function SendKeyEvent(eventName : String, e : LockStepKeyEvent)
    {
        var toSend = new PlayerKeyEvent();
        this.FillPlayerEvent(toSend);
        toSend.Key = e.Key;
        toSend.AltPressed = e.AltPressed;
        toSend.ShiftPressed = e.ShiftPressed;
        toSend.CtrlPressed = e.CtrlPressed;
        this.Owner.DispatchEvent(eventName, toSend);
    }
    
    function OnLockStepKeyDown(e : LockStepKeyEvent)
    {
        this.AddMovement(e, Keys.W, local Real3( 0.0, 0.0,  1.0));
        this.AddMovement(e, Keys.S, local Real3( 0.0, 0.0, -1.0));
        this.AddMovement(e, Keys.A, local Real3( 1.0, 0.0,  0.0));
        this.AddMovement(e, Keys.D, local Real3(-1.0, 0.0,  0.0));
        
        this.SendKeyEvent("PlayerKeyDown", e);
        
        // We still allow movement to happen when freezing input (we ignore it in update)
        if (this.FreezeKeyboardInput)
        {
            return;
        }
        
        if (this.Active)
        {
            if (e.Key == Keys.Space)
            {
                this.Owner.RigidBody.ApplyLinearVelocity(local Real3(0.0, this.JumpVelocity, 0.0));
            }
            
            if (e.Key >= Keys.Zero && e.Key <= Keys.Nine)
            {
                var index = e.Key - Keys.One;
                
                // Handle the '0' button case
                if (index == -1)
                {
                    index = 9;
                }
                
                if (e.ShiftPressed)
                {
                    index += 10;
                }
                
                // Check if the key was a valid key
                if (index >= 0 && index < this.Tools.Count)
                {
                    var newTool = this.Tools.Get(index);
                    if (this.ActiveTool != newTool)
                    {
                        this.DeactivateTool();
                        this.ActivateTool(newTool);
                    }
                }
            }
        }
        
        if (e.Key == Keys.Z && this.UndoStack.Count != 0)
        {
            var undo = this.UndoStack.Pop();
            var result = undo.Action(undo);
            
            // If we failed an undo, just clear the undo stack for now
            if (result == false)
            {
                this.UndoStack.Clear();
            }
            
            // If that was the last undo...
            if (this.UndoStack.Count == 0)
            {
                this.HudUndoText.Text = "";
            }
            else
            {
                var nextUndo = this.UndoStack.Get(this.UndoStack.LastIndex);
                this.HudUndoText.Text = String.Concatenate("Press [Z] to undo ", nextUndo.Name);
            }
        }
        
        if (e.Key == Keys.H)
        {
            this.Notify("Test of the notification system");
        }
        
        if (e.Key == Keys.E && this.InteractCog != null)
        {
            this.Space.SoundSpace.PlayCueAt(this.InteractSound, this.InteractCog.Transform.WorldTranslation);
            this.SendInteractEvent("Interact", this.InteractCog);
        }
    }
    
    function OnLockStepKeyUp(e : LockStepKeyEvent)
    {
        this.AddMovement(e, Keys.W, local Real3( 0.0, 0.0, -1.0));
        this.AddMovement(e, Keys.S, local Real3( 0.0, 0.0,  1.0));
        this.AddMovement(e, Keys.A, local Real3(-1.0, 0.0,  0.0));
        this.AddMovement(e, Keys.D, local Real3( 1.0, 0.0,  0.0));
        
        this.SendKeyEvent("PlayerKeyUp", e);
    }
    
    
    function DeactivateTool()
    {
        this.SendToolEvent("DeactivateTool", this.ActiveTool);
        this.HudToolText.Text = "";
        this.HudToolSubText.Text = "";
    }
    
    function ActivateTool(tool : Cog)
    {
        this.HudToolText.Text = tool.Name;
        this.HudToolSubText.Text = "";
        this.ActiveTool = tool;
        this.SendToolEvent("ActivateTool", this.ActiveTool);
        this.Space.SoundSpace.PlayCue(this.ChangeToolSound);
    }
    
    function SendToolEvent(eventName : String, to : Cog)
    {
        var toSend = new ToolChangeEvent();
        this.FillPlayerEvent(toSend);
        toSend.HudText = this.HudToolSubText;
        toSend.Hud = this.Hud;
        to.DispatchEvent(eventName, toSend);
    }
    
    function SendPlayerEventTo(eventName : String, to : Cog)
    {
        var toSend = new PlayerEvent();
        this.FillPlayerEvent(toSend);
        to.DispatchEvent(eventName, toSend);
    }
}

class HitResult
{
    var Object : Cog = null;
    var WorldNormal : Real3 = local Real3();
    var WorldPosition : Real3 = local Real3();
    
    constructor()
    {
    }
}

class Undo
{
    var Action : delegate(undo : Undo) : Boolean = Undo.DoNothing;
    var UniqueName : String = "";
    var Name : String = "Unknown";
    
    [Static]
    function DoNothing(undo : Undo) : Boolean
    {
        return false;
    }
    
    constructor()
    {
    }
}

class PlayerEvent : Event
{
    var Player : Player = null;
    var PlayerCog : Cog = null;
    
    constructor() : base()
    {
    }
}

class InteractEvent : PlayerEvent
{
    // If this gets set to anything but null, it means someone responded
    var Message : String = null;
    
    constructor() : base()
    {
    }
}

class ToolChangeEvent : PlayerEvent
{
    var HudText : ShadowText = null;
    var Hud : Space = null;
    
    constructor() : base()
    {
    }
}

class PlayerInputEvent : PlayerEvent
{
    var AltPressed : Boolean = false;
    var ShiftPressed : Boolean = false;
    var CtrlPressed : Boolean = false;
    
    constructor() : base()
    {
    }
}

class PlayerKeyEvent : PlayerInputEvent
{
    var Key : Integer = 0;
    
    constructor() : base()
    {
    }
}

class PlayerMouseEvent : PlayerInputEvent
{
    var ScreenDelta : Real2 = local Real2();
    var WorldStart : Real3 = local Real3();
    var WorldDirection : Real3 = local Real3();
    var Button : Integer = 0;
    var ScrollDelta : Real2 = local Real2();
    
    constructor() : base()
    {
    }
}

